//------------------------------------------------
//--- 010 Editor v2.0 Binary Template
//
//      File: WAV.bt
//    Author: SweetScape Software, Paulo Max Gil I Reis
//   Version: 1.2
//   Purpose: Parse WAV audio files.
//  Category: Audio
// File Mask: *.wav
//  ID Bytes: 52 49 46 46 [+4] 57 41 56 45 //RIFF????WAVE
//   History:  
//   1.2   2020-02-04 Paulo Max: Improved to correct parsing of DVI ADPCM and fix some issues in subchunk list parsing.
//   1.1   2015-10-05 SweetScape: Updated header for repository submission.
//   1.0   SweetScape: Initial release.
//
// More information available at:
//  https://en.wikipedia.org/wiki/WAV
//------------------------------------------------

// Record whether we have found a format chunk yet
local int haveValidFormat = false;

//-----------------------------------
// Define structures used in WAV files

// Stores the file header information
typedef struct 
{
    char   groupID[4];
    long   hsize; //set at the end
    char   riffType[4];
} WAVRIFFHEADER;
//Formattag ()
typedef enum < ushort > e_Format_Tags {
	PCM = 0x0001,
    MS_ADPCM = 0x0002,//3%, invalid number of samples in packet, block predictor invalid, needs compression algorithm to be fixed
	ALAW = 0x0006,//92%
	MULAW = 0x0007,//92%
	OKI_ADPCM = 0x0010,// 92%
	G723_ADPCM = 0x0014, //12%, invalid number of bits
	DILOGIC_OKI_ADPCM = 0x0017,//87%
	YAMAHA_ADPCM = 0x0020, //91%
	DSPGROUP_TRUESPEECH = 0x0022, //14%, too small input buffer, need at least 32 bytes
	GSM610 = 0x0031, //8%, packet too short
	NMS_VBXADPCM = 0x0038,//5%, corrupt bitstream
	G721_ADPCM = 0x0040, //26%, invalid number of bits
	MPEG_1_LAYER_I_II = 0x0050, //3%, header missing, invalid data found
	MPEG_1_LAYER_III_MP3 = 0x0055, //0%, header missing, invalid data found
	XBOX_ADPCM = 0x0069, //33%
	CREATIVE_ADPCM = 0x0200, //99%
} E_FORMAT_TAGS;

// Stores the format information for the file
typedef struct {
    char           chunkID[4];
    long           chunkSize = { 16 };
    local int pos = FTell();
    E_FORMAT_TAGS          wFormatTag; //bugfixing formats 
    unsigned short wChannels;
    unsigned long  dwSamplesPerSec;
    unsigned long  dwAvgBytesPerSec;
    local unsigned short bps = ReadUShort(FTell() + 2);
    unsigned short wBlockAlign = { (bps / 8) * wChannels }; 
    unsigned short wBitsPerSample;
    if (wFormatTag == 17) //DVI IMA ADPCM
    {
        unsigned short wcbsize;
        unsigned short wSamplesPerBlock;
    }

    // Mark that we have found a valid format chunk
    haveValidFormat = true;

    // Unknown data at the end of the chunk
    if( chunkSize > (FTell() - pos) )
        uchar unknown[ chunkSize - (FTell() - pos) ];

    // Padding so the next chunk starts on an even byte
    if( chunkSize & 1 )
        uchar padding;
} FORMATCHUNK;

// Stores the actual wave data
typedef struct 
{
    char           chunkID[4];
	local int size_pos = FTell();
    long           chunkSize <min=32>;

    // Test if we have a valid format
    if( !haveValidFormat )
    {
        Warning( "File contains no valid WAVE format chunk." );
        return -1;
    }

    // Parse the samples of the data
    if( ((format.wBitsPerSample != 8) && (format.wBitsPerSample != 16) && (format.wBitsPerSample != 32)) 
        || format.wBlockAlign == 0 || (chunkSize % (int)format.wBlockAlign != 0) )
    {
        // Unsupported storage method used
        unsigned char  waveformData[chunkSize];
    }
    else if( (format.wChannels == 1) && (format.wBitsPerSample == 8) )
    {
        // Define an array of 8-bit samples - common case
        uchar samples[ chunkSize ];
    }
    else if( (format.wChannels == 1) && (format.wBitsPerSample == 16) )
    {
        // Define an array of 16-bit samples - common case
        short samples[ chunkSize/2 ];
    }
    else if( (format.wChannels == 1) && (format.wBitsPerSample == 32) )
    {
        // Define an array of 32-bit samples - common case
        int samples[ chunkSize/4 ];
    }
    else
    {
        // Define general case sample
        struct SAMPLES {
            if( format.wBitsPerSample == 8 )
                 uchar channels[ format.wChannels ];
            else if( format.wBitsPerSample == 16 )
                 short channels[ format.wChannels ];
            else if( format.wBitsPerSample == 32 )
                 int   channels[ format.wChannels ];
        } samples[ chunkSize / (int)format.wBlockAlign ];
    }
	//Fix size TODO
	local long end = FTell();
	local long real_size = end - size_pos - 4;
	FSeek(size_pos);
	local int evil = SetEvilBit(false);
	long chunkSize = {real_size};
	SetEvilBit(evil);
	FSeek(end); 
    // Padding so the next chunk starts on an even byte
    if( (chunkSize & 1) && !FEof(0.0) )
        uchar padding;
} DATACHUNK;

// Stores the size of the wave after decompression
typedef struct
{
    char           chunkID[4];
    long           chunkSize = { 12 };
    unsigned long  uncompressedSize;
} FACTCHUNK;

// Stores a list of cue points or markers to points in the data
typedef struct {
    long    dwIdentifier;
    long    dwPosition;
    char    fccChunk[4];
    long    dwChunkStart;
    long    dwBlockStart;
    long    dwSampleOffset;
} CUEPOINT;

typedef struct {
    char      chunkID[4];
	local int size_pos = FTell();
    long      chunkSize;
    local int pos = FTell();
    long      dwCuePoints;
    CUEPOINT  points[dwCuePoints];
	//Fix size TODO
	local long end = FTell();
	FSeek(size_pos);
	local int evil = SetEvilBit(false);
	long chunkSize = {end - pos};
	SetEvilBit(evil);
	FSeek(end); 
    // Unknown data at the end of the chunk
    if( chunkSize > (FTell() - pos) )
        uchar unknown[ chunkSize - (FTell() - pos) ];
} CUECHUNK;

// Define a list chunk with a set of subchunks
typedef struct {
    char      chunkID[4];
	local int size_pos = FTell();
    long      chunkSize <min=1>;
    char      listData[chunkSize];

	//Fix size TODO
	local long end = FTell();
	local long real_size = end - size_pos - 4;
	FSeek(size_pos);
	local int evil = SetEvilBit(false);
	long chunkSize = {real_size};
	SetEvilBit(evil);
	FSeek(end); 
    if( (chunkSize & 1) && !FEof(0.0) )
        uchar padding;
} LISTSUBCHUNK;

typedef struct {
    char      chunkID[4];
    long      chunkSize <min=1>;
    local quad pos = FTell();
	local char list_tag[1];
    char      chunkType[4];
    local uint size;

    // Read the subchunks
    while( FTell() - pos <= chunkSize - 8 ) {
        size = ReadUInt( FTell()+4 );
        if  (FTell() - pos + size<= chunkSize)
            LISTSUBCHUNK subchunk;
        else
            break;
    }
    if ( FTell() - pos < chunkSize ) {
        uchar unknown[ chunkSize - (FTell() - pos) ];       
    }

    // Padding so the next chunk starts on an even byte
    if( (chunkSize & 1) && !FEof(0.0) )
        uchar padding;
} LISTCHUNK;

// A chunk which could not be identified
typedef struct {
    char      chunkID[4];
    long      chunkSize <min=1>;
    uchar     unknownData[chunkSize];

    // Padding so the next chunk starts on an even byte
    if( (chunkSize & 1) && !FEof(0.0) )
        uchar padding;
} UNKNOWNCHUNK;

//---------------------------------------------

// Define the headers
LittleEndian(); 
SetBackColor( cLtPurple );
WAVRIFFHEADER header;

// Check for valid header
if( header.groupID != "RIFF" || header.riffType != "WAVE" )
{
    Warning( "File is not a valid wave file. Template stopped." );
    return -1;
}

// Read the file as a set of chunks
local char chunk_tag[4];
local int compressed_wav = false;

local string ReadBytesInitValues[] = { "fmt ", "data", "fact", "cue ", "LIST", "id3 " };

local string tag_values_possible[] = { "fmt " };
local string tag_values_preferred[] = { "fmt " };

while(ReadBytes(chunk_tag, FTell(), 4, tag_values_preferred, tag_values_possible)){
    // See which chunk this is
    switch( chunk_tag )
    {
        case "fmt ":
            SetBackColor( cLtGray );
            FORMATCHUNK format;
			tag_values_preferred -= "fmt "; //remove fmt tag, it is only allowed once
			tag_values_possible -= "fmt ";
			tag_values_preferred += "data";
			tag_values_possible += "data";
            break;
        case "data":
            SetBackColor( cNone );
            DATACHUNK   data;
			tag_values_preferred -= "data"; //remove data tag, it is only allowed once
			tag_values_possible -= "data";
			tag_values_possible += ( "fact", "cue ", "LIST"); //TODO enforce fact chunk for compressed formats, check list
            break;
		//TODO check number of occurences for fact chunk
        case "fact":
            SetBackColor( cLtBlue );
            FACTCHUNK   fact;
			tag_values_possible -= "fact";
			tag_values_preferred -= "fact" ;
            break;
        case "cue ":
            SetBackColor( cLtGray );
            CUECHUNK    cue;
			tag_values_preferred -= "cue "; //remove cue tag, it is only allowed once
			tag_values_possible -= "cue ";
            break;
        case "LIST":
            SetBackColor( cLtYellow );
            LISTCHUNK   list;
            break;
        default:
            // Unknown chunk
            SetBackColor( cNone );
            UNKNOWNCHUNK unknown;
            break;
    }
}

// adding file size to header, needed to be parsed
local int file_size = FTell();
FSeek(4);
long hsize = { file_size - 8 };

